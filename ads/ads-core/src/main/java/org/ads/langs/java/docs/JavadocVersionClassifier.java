package org.ads.langs.java.docs;

import org.ads.langs.java.Version;
import org.ads.utils.CustomListUtils;
import org.ads.utils.CustomObjectUtils;
import org.ads.utils.CustomStringUtils;
import org.ads.utils.Parameters;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Node;

import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.List;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/**
 * Javadoc version simple classifier.<br />
 * 
 * @author arrebola
 *
 */
public class JavadocVersionClassifier {

  private static final String GENERATED_STRING = "Generated by javadoc";
  private static final Pattern pattern = Pattern.compile("1.[0-8].[0-9]");

  private static final String MANIFEST_FILE = "META-INF/MANIFEST.MF";
  private static final String BUILD_JDK = "Build-Jdk";

  private static final Logger LOGGER = LogManager.getLogger(JavadocVersionClassifier.class);

  /**
   * Gets the most likely Javadoc version of a {@link Jsoup} {@link Document} using the HTML comment
   * that contains the fragment {@value #GENERATED_STRING}.<br />
   * 
   * @param document
   *          the {@link Jsoup} {@link Document} to be parsed
   * 
   * @return the most likely {@link Version} or {@link Version#UNDEFINED} if none is found
   */
  private static Version getMostLikelyVersionUsingJSoup(Document document) {

    Version version = Version.UNDEFINED;

    List<Node> childNodes = document.getElementsByTag("head").first().childNodes();
    if (CustomListUtils.isEmpty(childNodes)) {
      return version;
    }

    boolean found = false;
    Iterator<Node> iterator = childNodes.iterator();
    while (iterator.hasNext() && !found) {

      Node node = iterator.next();

      // we are only interested in comments
      if (!(node instanceof Comment)) {
        continue;
      }

      // comments should contains the 'Generated by javadoc' text fragment
      final String data = ((Comment) node).getData();
      if (!CustomStringUtils.contains(data, GENERATED_STRING)) {
        continue;
      }

      Matcher matcher = pattern.matcher(data);
      if (matcher.find()) {
        final String fullVersion = matcher.group();
        if (CustomStringUtils.isNotEmpty(fullVersion)) {
          version = Version.parse(fullVersion.substring(0, 3));
          found = true;
        }
      }

    }

    return version;

  }

  /**
   * Gets the most likely Javadoc version of {@link ZipFile} using the MANIFEST.MF attribute
   * {@link #BUILD_JDK}.<br />
   * 
   * @param zipFile
   *          the {@link ZipFile} to be parsed
   * 
   * @return the most likely {@link Version} or {@link Version#UNDEFINED} if none is found
   */
  private static Version getMostLikelyVersionUsingManifest(ZipFile zipFile) {

    Version version = Version.UNDEFINED;

    final ZipEntry entry = zipFile.getEntry(MANIFEST_FILE);
    if (CustomObjectUtils.isNull(entry)) {
      return version;
    }

    try (InputStream is = zipFile.getInputStream(entry)) {

      Manifest manifest = new Manifest(is);
      Attributes attributes = manifest.getMainAttributes();
      final String data = attributes.getValue(BUILD_JDK);
      if (CustomStringUtils.isEmpty(data)) {
        throw new IOException("Could not find BUILD_JDK attribute.");
      }

      Matcher matcher = pattern.matcher(data);
      if (matcher.find()) {
        final String fullVersion = matcher.group();
        if (CustomStringUtils.isNotEmpty(fullVersion)) {
          version = Version.parse(fullVersion.substring(0, 3));
        }
      }

    } catch (IOException exception) {
      LOGGER.warn("Failed to parse MANIFEST.MF ({}).", exception.getMessage());
    }

    return version;

  }

  /**
   * Gets the most likely Javadoc version using two complementary approaches.<br />
   * The first one reads the given {@link Jsoup} {@link Document} and searches for the HTML comment
   * that contains the fragment {@value #GENERATED_STRING}.<br />
   * The second one reads the attribute {@link #BUILD_JDK} manifest attribute of the given
   * {@link ZipFile}.<br />
   * 
   * @param document
   *          the {@link Jsoup} {@link Document} to be parsed
   * @param zipFile
   *          the {@link ZipFile} to be parsed
   * 
   * @return the most likely {@link Version} or {@link Version#UNDEFINED} if none is found
   */
  public static Version getMostLikely(Document document, ZipFile zipFile) {

    Parameters.requireNonNull(zipFile, zipFile);

    Version version = getMostLikelyVersionUsingJSoup(document);
    if (Version.UNDEFINED.equals(version)) {
      version = getMostLikelyVersionUsingManifest(zipFile);
    }

    return version;

  }

}